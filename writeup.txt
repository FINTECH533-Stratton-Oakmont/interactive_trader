Strategy:
The strategy we will be using in our trading algorithm is a pairs trading model using a cointegration approach. We will be mainly working around the "spread" or the difference in the z-transformed log prices between both stocks. Our strategy revolves around the assumption  that the log-price of the stocks we are trading exhibit mean-reverting behavior, i.e. stationary. This means that we assume that the log-prices of these  stocks will eventually return to their average, and we can identify opportunities for arbitrage if one stock's log price is much higher than their average  and another's is much lower than their average. Based on a certain threshold, i.e., a defined number of standard deviations, we can identify opportunities to enter (i.e., place a trade) when the spread is higher than this threshold. Once we enter, we would buy the stock that has a log-price higher than its average and sell the stock that has a log-price lower than its average. Once the spread shrinks and is essentially 0, we can exit the position and close the trade. We can also exit the position if it has been open for too long (in our case, 90 days). Our main risk in this position is if the stock price moves away from the mean, or does the opposite of mean reversion.

Code:
entry_signal:
The entry_signal function takes the following inputs: the log-price data over time for both stocks as pandas dataframes, the ticker symbols for both stocks, the position taken (which will always be 0 or no position taken as we are entering the trade), the threshold (i.e., number of standard deviations we use for our entry signal), the allocation (amount of money put into the trade) and the column names we want our blotter to have (i.e. Date, Status, Trip, Symbol, Price, Action and Size). 

First, we perform linear regression on the log-price data of both stocks and store the results of the model (slope and intercept) into their own variables. We also compute 'sigma', which is the standard deviation of the residuals. Using these variables, we can compute the z-score of both stocks by dividing the residuals by sigma. From here, we create a data frame called 'spread', that contains the residuals, z-score, log-prices for both stocks and dates. We can also compute the weights assigned to each stock as the slope/1+slope and 1/1+slope. Finally, we set the status variable to "Filled".

From here, use conditional logic to identify whether we should open a position or not. If the final z-score value of 'spread' is greater than the threshold * 'sigma' and the second to last value is less than the threshold * 'sigma', we open a "long-spread" position and represent this by changing "position_taken" to 1. From here, we compute the sizes of both stocks by multiplying the weight computed earlier by the allocation and the latest market price. Then, we create two new variables "stock_1_order" and "stock_2_order" that contain the date, status, trip (always 'Entry'), ticker, price, action (buy for stock 1 and sell for stock 2) and size. We then add this into a new dataframe called 'df'. 

Similarly, if we see that the final z-score value of 'spread' is less than the negative of threshold * 'sigma' and the second to last value is greater than the negative of threshold * 'sigma', we open a "short-spread" position and represent this by changing "position_taken" to negative 1. The rest of the code would function similarly (i.e., calculating weights and creating "df") with the main difference being we sell stock 1 and buy stock 2. 

If none of these conditions are satisfied, "position_taken" remains at 0 because the entry signal has not been satisfied and thus no trade will be placed and "df" remains as an empty data frame. The final output of this code is "df", the "position_taken" variable and the "spread" dataframe.

exit_signal:
The exit_signal function takes the following inputs: log-price data of both stocks as a pandas data frame, the ticker symbol for both stocks, the position taken (either long-spread, short-spread or no position), the dataframe output "df" from entry_signal as "blotter", the spread data frame calculated from entry_signal and the column names we want the blotter to have.

Firstly, we change the status of each order to "FILLED" as we are exiiting the position regardless. If we are using a long-spread, and the final z-score value in "spread" is negative, we use the last two values of "Size" in "blotter" as the size of the trades for stock 2 and 1, respectively. We would then create two new variables similar to "stock_1_order" and "stock_2_order" in entry_signal, except we change the trip to 'Exit' and reverse the action (sell for stock 1 and buy for stock 2), to effectively close the position. We then add these rows into an empty data frame called "df" and set the position taken to 0, as we have exited the position. Similarly, if we are using a short-spread and the final z-score value in "spread" is positive, we run the code the same way. Since we are exiting the position of a short-spread, we will be buying stock 1 and selling stock 2 to close the position. If none of these conditions are satisfied, we simply return an empty data frame.

backtest:
Finally, we want to check our results on historical data to see how our algorithm performs. We created a function called backtest that runs entry_signal and exit_signal as described above and ultimately returns a blotter containing all the trades that would have been executed over a 90-day time period. This blotter now serves as our  ledger. 
